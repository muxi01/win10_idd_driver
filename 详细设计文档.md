# IddSampleDriver 详细设计文档

## 文档信息

- **项目名称**: IddSampleDriver - USB虚拟显示驱动
- **版本**: v1.0
- **目标受众**: 驱动开发人员
- **文档类型**: 架构设计与接口说明

---

## 目录

1. [概述](#1-概述)
2. [系统架构](#2-系统架构)
3. [核心模块设计](#3-核心模块设计)
4. [USB描述符解析过程](#4-usb描述符解析过程)
5. [IDDCX屏幕数据抓取流程](#5-iddcx屏幕数据抓取流程)
6. [函数调用顺序](#6-函数调用顺序)
7. [数据流程](#7-数据流程)
8. [错误处理机制](#8-错误处理机制)

---

## 1. 概述

### 1.1 项目简介

IddSampleDriver 是基于 Windows Indirect Display (IDDCX) 框架开发的用户模式显示驱动,将 Windows 桌面画面通过 USB 接口传输到外部显示设备。

### 1.2 技术栈

| 组件 | 技术/框架 |
|------|----------|
| 驱动框架 | UMDF 2.25 (User-Mode Driver Framework) |
| 显示框架 | IDDCX (Indirect Display Class Extension) |
| 图形接口 | DirectX 11, DXGI 1.5 |
| USB框架 | WDF USB (Windows Driver Framework USB) |
| 图像编码 | libjpeg-turbo (JPEG压缩) |
| 支持格式 | RGB565, RGB888, JPEG |

### 1.3 关键特性

- 异步 USB 数据传输 (URB池机制)
- 多种图像编码格式支持
- 性能统计和监控
- USB热插拔支持
- 动态分辨率适配
- 帧率控制

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                   Windows Desktop Layer                   │
│              (DXGI Surface / SwapChain)                 │
└─────────────────────────┬───────────────────────────────┘
                        │
                        │ IDDCX Callbacks
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              IDDCX Class Extension                      │
│   - IddCxSwapChainReleaseAndAcquireBuffer             │
│   - IddCxSwapChainFinishedProcessingFrame             │
└─────────────────────────┬───────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              IddSampleDriver (UMDF 2.25)              │
│                                                         │
│  ┌──────────────────────────────────────────────────┐    │
│  │  IndirectDeviceContext                        │    │
│  │  - Adapter/Monitor管理                       │    │
│  │  - USB设备上下文                             │    │
│  │  - 配置管理                                  │    │
│  └──────────────────────────────────────────────────┘    │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐    │
│  │  SwapChainProcessor (独立线程)                │    │
│  │  - 帧抓取 (Direct3D)                       │    │
│  │  - 图像编码                                  │    │
│  │  - USB传输                                  │    │
│  │  - 性能统计                                  │    │
│  └──────────────────────────────────────────────────┘    │
│                                                         │
│  ┌──────────────────┐  ┌─────────────────────┐        │
│  │  Direct3DDevice  │  │  ImageEncoder      │        │
│  │  - D3D设备管理   │  │  - RGB565/RGB888  │        │
│  │  - GPU渲染      │  │  - JPEG压缩       │        │
│  └──────────────────┘  └─────────────────────┘        │
│                                                         │
│  ┌──────────────────────────────────────────────────┐    │
│  │  USB Driver (usb_driver.cpp)                  │    │
│  │  - URB池管理                                │    │
│  │  - 异步传输                                 │    │
│  │  - 设备枚举                                 │    │
│  └──────────────────────────────────────────────────┘    │
└─────────────────────────┬───────────────────────────────┘
                        │ WDF USB Target
                        ▼
┌─────────────────────────────────────────────────────────────┐
│                 USB Bus Driver (usbhub.sys)               │
└─────────────────────────┬───────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              USB Hardware / ACM Device                    │
│              (CDC/ACM or Bulk endpoints)                 │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 模块依赖关系

```
Driver.cpp
    ├─> Driver.h
    ├─> usb_driver.h/cpp
    ├─> encoder.h/cpp
    ├─> tools.h/c
    └─> Trace.h

usb_driver.cpp
    ├─> usb_driver.h
    ├─> basetype.h
    ├─> tools.h
    └─> WDF USB APIs

encoder.cpp
    ├─> encoder.h
    ├─> basetype.h
    ├─> tools.h
    └─> jpeglib.h (libjpeg-turbo)

tools.c
    ├─> tools.h
    └─> basetype.h
```

---

## 3. 核心模块设计

### 3.1 Driver.cpp - 主驱动模块

#### 3.1.1 核心类结构

##### IndirectDeviceContextWrapper

```cpp
class IndirectDeviceContextWrapper {
public:
    Microsoft::IndirectDisp::IndirectDeviceContext* pContext;

    // USB设备资源
    WDFUSBDEVICE UsbDevice;
    WDFUSBINTERFACE UsbInterface;
    WDFUSBPIPE BulkReadPipe;
    ULONG max_in_pkg_size;
    WDFUSBPIPE BulkWritePipe;
    ULONG max_out_pkg_size;
    ULONG UsbDeviceTraits;

    PSLIST_HEADER purb_list;  // URB池

    // 配置信息
    config_cstr_t udisp_registry_dev_info;
    config_cstr_t udisp_dev_info;
    TCHAR tchar_udisp_devinfo[UDISP_CONFIG_STR_LEN];
    display_config_t config;

    // 状态管理
    usb_connection_state_t usb_state;
    perf_stats_t perf_stats;

    void Cleanup();
};
```

**功能**:
- 封装USB设备和显示器的上下文信息
- 管理URB池
- 保存驱动配置
- 追踪性能统计

##### SwapChainProcessor

```cpp
class SwapChainProcessor {
public:
    SwapChainProcessor(IDDCX_SWAPCHAIN hSwapChain,
                   std::shared_ptr<Direct3DDevice> Device,
                   WDFDEVICE WdfDevice,
                   HANDLE NewFrameEvent);

private:
    IDDCX_SWAPCHAIN m_hSwapChain;
    std::shared_ptr<Direct3DDevice> m_Device;
    WDFDEVICE mp_WdfDevice;

    // 帧缓冲区 (最大1920x1080x4字节)
    uint8_t fb_buf[DISP_MAX_HEIGHT * DISP_MAX_WIDTH * 4];

    ImageEncoder *m_pEncoder;     // 图像编码器
    SLIST_HEADER urb_list;        // URB池
    int max_out_pkg_size;         // USB OUT包最大大小

    HANDLE m_hAvailableBufferEvent;  // 新帧可用事件
    Microsoft::WRL::Wrappers::Thread m_hThread;
    Microsoft::WRL::Wrappers::Event m_hTerminateEvent;
};
```

**功能**:
- 在独立线程中处理SwapChain帧
- 从DXGI Surface抓取帧数据
- 编码图像数据
- 通过USB发送到外部设备
- 性能监控和统计

#### 3.1.2 主要回调函数

| 回调函数 | 触发时机 | 功能 |
|---------|---------|------|
| `DriverEntry` | 驱动加载 | 初始化WDF驱动框架 |
| `IddSampleDeviceAdd` | 设备添加 | 创建WDF设备对象,注册IDDCX回调 |
| `IddSampleDevicePrepareHardware` | 硬件准备 | 初始化USB设备,选择接口 |
| `IddSampleDeviceReleaseHardware` | 硬件释放 | 清理USB资源 |
| `IddSampleDeviceSurpriseRemoval` | 设备意外移除 | 处理USB热插拔 |
| `IddSampleAdapterInitFinished` | 适配器初始化完成 | 通知IDDCX适配器已就绪 |
| `IddSampleParseMonitorDescription` | 解析显示器描述 | 返回EDID和模式信息 |
| `IddSampleMonitorAssignSwapChain` | 分配SwapChain | 创建SwapChainProcessor线程 |
| `IddSampleMonitorUnassignSwapChain` | 释放SwapChain | 停止并销毁SwapChainProcessor |

### 3.2 usb_driver.cpp - USB传输模块

#### 3.2.1 数据结构

##### urb_item_t (URB传输单元)

```cpp
typedef struct _urb_item {
    SLIST_ENTRY node;           // 单链表节点
    WDFUSBPIPE pipe;            // USB管道
    int id;                    // URB ID
    uint8_t* urb_msg;           // 数据缓冲区
    int urb_msg_size;           // 缓冲区大小
    PSLIST_HEADER urb_list;      // 所属URB池
    WDFREQUEST Request;          // WDF请求对象
    WDFMEMORY wdfMemory;        // WDF内存对象
} urb_item_t;
```

**功能**: USB传输的基本单元,包含数据缓冲区、请求对象和状态信息。

#### 3.2.2 全局变量

```cpp
static usb_connection_state_t g_usb_state = USB_STATE_DISCONNECTED;
static volatile LONG g_usb_init_flag = 0;
static WDFWAITLOCK g_usb_state_lock = NULL;
```

- `g_usb_state`: USB连接状态 (连接/断开/错误/恢复中)
- `g_usb_init_flag`: USB初始化标志
- `g_usb_state_lock`: 状态锁,保护USB状态变更

#### 3.2.3 主要函数

| 函数名 | 功能 | 调用位置 |
|-------|------|---------|
| `usb_send_data_async` | 异步发送数据 | SwapChainProcessor主循环 |
| `usb_send_data_sync` | 同步发送数据 | 可选的同步发送接口 |
| `usb_select_interface` | 选择USB接口和管道 | IddSampleDevicePrepareHardware |
| `usb_get_discribe_info` | 获取USB设备描述符信息 | IddSampleDevicePrepareHardware |
| `usb_device_connect` | 设置USB连接状态 | SwapChainProcessor启动时 |
| `usb_device_disconnect` | 设置USB断开状态 | IddSampleDeviceSurpriseRemoval |
| `usb_is_connected` | 检查USB连接状态 | SwapChainProcessor主循环 |
| `usb_resouce_init` | 初始化URB池 | SwapChainProcessor构造时 |
| `usb_resouce_distory` | 销毁URB池 | SwapChainProcessor析构时 |

### 3.3 encoder.cpp - 图像编码模块

#### 3.3.1 核心类

```cpp
class ImageEncoder {
public:
    ImageEncoder(int type, int quality = 0);
    ~ImageEncoder();

    int encode(uint8_t* output, const uint8_t* input,
             int buffer_size, int x, int y,
             int width, int height);

private:
    int encode_rgb565(...);      // RGB565编码
    int encode_rgb888(...);      // RGB888编码
    int encode_jpeg(...);        // JPEG编码

    struct jpeg_encoder_private_t* m_jpeg_private;
    int m_type;                // 编码类型
    int m_quality;             // JPEG质量
    _u32 m_counter;           // 帧计数
};
```

#### 3.3.2 支持的编码类型

| 编码类型 | 常量 | 数据格式 | 压缩比 | 用途 |
|---------|-------|---------|--------|------|
| RGB565 | `IMAGE_TYPE_RGB565` | 16位/像素 | 1:2 | 低带宽,低质量 |
| RGB888 | `IMAGE_TYPE_RGB888` | 24位/像素 | 1:1 | 未压缩,高质量 |
| JPEG | `IMAGE_TYPE_JPG` | 可变 | 1:10 ~ 1:30 | 高带宽压缩 |
| NULL | `IMAGE_TYPE_NULL` | - | - | 占位符 |

#### 3.3.3 帧头格式

```cpp
typedef struct _image_frame_header_t {
    _u32 magic_id;   // 魔数: 0x6C76736E ('lvsn')
    _u32 img_type;   // 图像类型: 3=JPEG
    _u32 img_len;    // 图像数据长度(不含帧头)
    _u32 img_cnt;    // 帧计数
} image_frame_header_t;
```

**总长度**: 16字节

### 3.4 tools.c - 工具函数模块

#### 3.4.1 日志系统

```cpp
enum LogLevel {
    LOG_LEVEL_ERROR = 0,
    LOG_LEVEL_WARN = 1,
    LOG_LEVEL_INFO = 2,
    LOG_LEVEL_DEBUG = 3,
    LOG_LEVEL_TRACE = 4
};

extern LONG debug_level;  // 全局日志级别

// 日志宏
#define LOGE(fmt, ...)  // ERROR级别
#define LOGW(fmt, ...)  // WARN级别
#define LOGI(fmt, ...)  // INFO级别
#define LOGD(fmt, ...)  // DEBUG级别
```

#### 3.4.2 性能统计

```cpp
typedef struct _perf_stats {
    uint64_t total_frames;       // 总帧数
    uint64_t dropped_frames;     // 丢弃帧数
    uint64_t error_frames;      // 错误帧数
    uint64_t total_bytes;       // 总传输字节数
    uint64_t urbs_sent;        // 发送的URB数
    uint64_t urbs_failed;      // 失败的URB数
    int64_t avg_grab_time_us;  // 平均抓取时间(微秒)
    int64_t avg_encode_time_us; // 平均编码时间(微秒)
    int64_t avg_send_time_us;   // 平均发送时间(微秒)
    int64_t avg_total_time_us;  // 平均总时间(微秒)
} perf_stats_t;
```

#### 3.4.3 主要函数

| 函数名 | 功能 |
|-------|------|
| `tools_get_time_us` | 获取高精度时间(微秒) |
| `tools_log` | 输出日志到DebugView |
| `tools_sample_tick` | FPS控制,按指定帧率休眠 |
| `tools_perf_stats_init` | 初始化性能统计 |
| `tools_perf_stats_update` | 更新性能统计 |
| `tools_perf_stats_print` | 打印性能统计 |
| `tools_split_config_str` | 解析配置字符串 |
| `tools_parse_usb_dev_info` | 解析USB设备配置 |

---

## 4. USB描述符解析过程

### 4.1 USB设备枚举流程

```
IddSampleDevicePrepareHardware
    │
    ├─> WdfUsbTargetDeviceCreateWithParameters()
    │   └─ 创建USB设备对象
    │
    ├─> usb_get_discribe_info()
    │   │
    │   ├─> WdfUsbTargetDeviceGetDeviceDescriptor()
    │   │   └─ 获取设备描述符 (VID/PID)
    │   │       LOGI("USB device VID:PID: 0x%04x:0x%04x\n", ...)
    │   │
    │   └─> WdfUsbTargetDeviceQueryString()
    │       └─ 获取产品字符串描述
    │           LOGI("Product: %d chars, %S\n", ...)
    │
    └─> usb_select_interface()
        │
        ├─> WdfUsbTargetDeviceGetNumInterfaces()
        │   └─ 获取接口总数
        │
        └─> for (UCHAR ifIndex = 0; ifIndex < numInterfaces; ifIndex++)
            │
            ├─> WdfUsbTargetDeviceGetInterface()
            │   └─ 获取指定接口
            │
            ├─> WdfUsbInterfaceGetInterfaceNumber()
            │   └─ 获取接口号 (bInterfaceNumber)
            │
            ├─> WdfUsbInterfaceGetNumConfiguredPipes()
            │   └─ 获取该接口的管道数
            │
            └─> for (UCHAR pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                │
                ├─> WdfUsbInterfaceGetConfiguredPipe()
                │   └─ 获取管道信息
                │       WDF_USB_PIPE_INFORMATION {
                │           USHORT MaximumPacketSize;
                │           UCHAR EndpointAddress;
                │           UCHAR PipeType;
                │           ...
                │       }
                │
                ├─> WdfUsbTargetPipeSetNoMaximumPacketSizeCheck()
                │   └─ 禁用最大包大小检查
                │
                ├─> Log Pipe Info
                │   └─ 打印管道信息
                │       LOGI("  Pipe %d: Type=%d, Direction=%s, Endpoint=0x%02x, MaxPacket=%d\n")
                │
                ├─> Check Pipe Type
                │   └─ 判断管道类型:
                │       if (WdfUsbPipeTypeBulk)
                │           └─> if (WdfUsbTargetPipeIsInEndpoint())
                │                   └─> BulkReadPipe (数据接收)
                │               else
                │                   └─> BulkWritePipe (数据发送)
                │
                └─> Save Pipe Info
                    ├─> pContext->BulkReadPipe = pipe
                    ├─> pContext->max_in_pkg_size = pipeInfo.MaximumPacketSize
                    ├─> pContext->BulkWritePipe = pipe
                    └─> pContext->max_out_pkg_size = pipeInfo.MaximumPacketSize
```

### 4.2 USB描述符解析详细步骤

#### 步骤1: 创建USB设备对象

**函数**: `idd_usbdisp_evt_device_prepareHardware` (Driver.cpp:1027-1076)

```cpp
// UMDF 2.25 或更高版本
WDF_USB_DEVICE_CREATE_CONFIG createParams;
WDF_USB_DEVICE_CREATE_CONFIG_INIT(&createParams, USBD_CLIENT_CONTRACT_VERSION_602);

status = WdfUsbTargetDeviceCreateWithParameters(
    Device,
    &createParams,
    WDF_NO_OBJECT_ATTRIBUTES,
    &pDeviceContext->UsbDevice);
```

**关键参数**:
- `USBD_CLIENT_CONTRACT_VERSION_602`: USB驱动契约版本
- 返回: `pDeviceContext->UsbDevice` (WDFUSBDEVICE句柄)

#### 步骤2: 获取设备描述符

**函数**: `usb_get_discribe_info` (usb_driver.cpp:92-137)

```cpp
// 获取设备描述符
USB_DEVICE_DESCRIPTOR udesc;
WdfUsbTargetDeviceGetDeviceDescriptor(pDeviceContext->UsbDevice, &udesc);

// 记录VID/PID
LOGI("USB device VID:PID: 0x%04x:0x%04x\n",
      udesc.idVendor, udesc.idProduct);

// 设备描述符结构
typedef struct _USB_DEVICE_DESCRIPTOR {
    UCHAR  bLength;
    UCHAR  bDescriptorType;
    USHORT bcdUSB;
    UCHAR  bDeviceClass;
    UCHAR  bDeviceSubClass;
    UCHAR  bDeviceProtocol;
    UCHAR  bMaxPacketSize0;
    USHORT idVendor;      // 厂商ID
    USHORT idProduct;     // 产品ID
    USHORT bcdDevice;
    UCHAR  iManufacturer;
    UCHAR  iProduct;      // 产品字符串索引
    UCHAR  iSerialNumber;
    UCHAR  bNumConfigurations;
} USB_DEVICE_DESCRIPTOR;
```

#### 步骤3: 获取产品字符串

**函数**: `usb_get_discribe_info` (续)

```cpp
// 第一次调用: 获取字符串长度
USHORT numCharacters = 0;
WdfUsbTargetDeviceQueryString(
    pDeviceContext->UsbDevice,
    NULL,
    NULL,
    NULL,
    &numCharacters,
    udesc.iProduct,
    0x0409  // 语言ID: 英语(美国)
);

// 第二次调用: 获取字符串内容
TCHAR stringBuf[UDISP_CONFIG_STR_LEN];
WdfUsbTargetDeviceQueryString(
    pDeviceContext->UsbDevice,
    NULL,
    NULL,
    stringBuf,
    &numCharacters,
    udesc.iProduct,
    0x0409
);

LOGI("Product: %d chars, %S\n", numCharacters, stringBuf);
```

#### 步骤4: 选择接口并配置管道

**函数**: `usb_select_interface` (usb_driver.cpp:140-217)

```cpp
// 获取接口总数
UCHAR numInterfaces = WdfUsbTargetDeviceGetNumInterfaces(pDeviceContext->UsbDevice);
LOGI("Device has %d interfaces\n", numInterfaces);

// 遍历所有接口
for (UCHAR ifIndex = 0; ifIndex < numInterfaces; ifIndex++) {
    // 获取接口对象
    WDFUSBINTERFACE usbInterface =
        WdfUsbTargetDeviceGetInterface(pDeviceContext->UsbDevice, ifIndex);

    // 获取接口号 (对应USB描述符中的bInterfaceNumber)
    UCHAR interfaceNumber = WdfUsbInterfaceGetInterfaceNumber(usbInterface);

    // 获取该接口的管道数
    UCHAR numPipes = WdfUsbInterfaceGetNumConfiguredPipes(usbInterface);
    LOGI("Interface %d (bInterfaceNumber=%d): %d pipes\n",
          ifIndex, interfaceNumber, numPipes);

    // 遍历该接口的所有管道
    for (UCHAR pipeIndex = 0; pipeIndex < numPipes; pipeIndex++) {
        WDF_USB_PIPE_INFORMATION pipeInfo;
        WDF_USB_PIPE_INFORMATION_INIT(&pipeInfo);

        // 获取管道对象
        WDFUSBPIPE pipe = WdfUsbInterfaceGetConfiguredPipe(
            usbInterface, pipeIndex, &pipeInfo);

        // 禁用最大包大小检查(允许发送超过最大包大小的数据)
        WdfUsbTargetPipeSetNoMaximumPacketSizeCheck(pipe);

        // 记录管道信息
        LOGI("  Pipe %d: Type=%d, Direction=%s, Endpoint=0x%02x, MaxPacket=%d\n",
              pipeIndex,
              pipeInfo.PipeType,
              WdfUsbTargetPipeIsInEndpoint(pipe) ? "IN" : "OUT",
              pipeInfo.EndpointAddress,
              pipeInfo.MaximumPacketSize);

        // 管道类型判断
        if (pipeInfo.PipeType == WdfUsbPipeTypeBulk) {
            if (WdfUsbTargetPipeIsInEndpoint(pipe)) {
                // Bulk IN 管道 (从设备读取数据)
                pContext->BulkReadPipe = pipe;
                pContext->max_in_pkg_size = pipeInfo.MaximumPacketSize;
                pContext->UsbInterface = usbInterface;
                LOGI("Found BulkRead Pipe on interface %d: 0x%p, max_packet_size: %d\n",
                      interfaceNumber, pipe, pContext->max_in_pkg_size);
            }
            else {
                // Bulk OUT 管道 (向设备写入数据)
                pContext->BulkWritePipe = pipe;
                pContext->max_out_pkg_size = pipeInfo.MaximumPacketSize;
                pContext->UsbInterface = usbInterface;
                LOGI("Found BulkWrite Pipe on interface %d: 0x%p, max_packet_size: %d\n",
                      interfaceNumber, pipe, pContext->max_out_pkg_size);
            }
        }
    }
}

// 验证配置
if (pContext->BulkWritePipe == NULL || pContext->BulkReadPipe == NULL) {
    LOGE("Device not properly configured: BulkReadPipe=%p, BulkWritePipe=%p\n",
          pContext->BulkReadPipe, pContext->BulkWritePipe);
    return STATUS_INVALID_DEVICE_STATE;
}

LOGI("USB configured successfully with BulkRead and BulkWrite pipes\n");
return STATUS_SUCCESS;
```

#### 步骤5: 管道信息结构

```cpp
typedef struct _WDF_USB_PIPE_INFORMATION {
    USHORT MaximumPacketSize;      // 最大包大小(字节)
    UCHAR  EndpointAddress;        // 端点地址
    UCHAR  Interval;              // 中断轮询间隔(毫秒)
    UCHAR  PipeType;              // 管道类型
    ULONG  PipeFlags;            // 管道标志
} WDF_USB_PIPE_INFORMATION, *PWDF_USB_PIPE_INFORMATION;

// 管道类型
enum WDF_USB_PIPE_TYPE {
    WdfUsbPipeTypeInvalid = 0,
    WdfUsbPipeTypeControl,        // 控制管道
    WdfUsbPipeTypeIsochronous,   // 等时管道
    WdfUsbPipeTypeBulk,         // 批量管道 ← 本项目使用
    WdfUsbPipeTypeInterrupt      // 中断管道
};
```

### 4.3 示例日志输出

```
[INFO] USB device VID:PID: 0x303A:0x2987
[INFO] Product: 32 chars, LV USB Display
[INFO] Device has 1 interfaces
[INFO] Interface 0 (bInterfaceNumber=0): 2 pipes
[INFO]   Pipe 0: Type=2, Direction=IN, Endpoint=0x81, MaxPacket=512
[INFO] Found BulkRead Pipe on interface 0: 0xFFFFFE578B79EDA8, max_packet_size: 512
[INFO]   Pipe 1: Type=2, Direction=OUT, Endpoint=0x01, MaxPacket=512
[INFO] Found BulkWrite Pipe on interface 0: 0xFFFFFE578B79EDB0, max_packet_size: 512
[INFO] USB configured successfully with BulkRead and BulkWrite pipes
```

---

## 5. IDDCX屏幕数据抓取流程

### 5.1 IDDCX框架概述

IDDCX (Indirect Display Class Extension) 是 Windows 10 引入的虚拟显示驱动框架,允许用户模式驱动程序创建虚拟显示器。

### 5.2 初始化流程

```
DriverEntry
    │
    └─> WdfDriverCreate()
        │
        └─> IddSampleDeviceAdd()
            │
            ├─> 注册PNP/Power回调
            │   └─> IddCxDeviceInitConfig()
            │
            ├─> 注册IDDCX回调
            │   ├─> EvtIddCxAdapterInitFinished
            │   ├─> EvtIddCxParseMonitorDescription
            │   ├─> EvtIddCxMonitorGetDefaultDescriptionModes
            │   ├─> EvtIddCxMonitorQueryTargetModes
            │   ├─> EvtIddCxAdapterCommitModes
            │   ├─> EvtIddCxMonitorAssignSwapChain
            │   └─> EvtIddCxMonitorUnassignSwapChain
            │
            ├─> WdfDeviceCreate()
            │
            └─> IndirectDeviceContext(Device)
                │
                ├─> CreateMonitor()
                │   └─> IddCxMonitorCreate()
                │       └─> IddCxMonitorArrival()
                │
                └─> InitAdapter()
                    └─> IddCxAdapterInitAsync()
```

### 5.3 屏幕数据抓取完整流程

#### 阶段1: SwapChain分配

**触发**: 用户扩展桌面到虚拟显示器时

```
IddSampleMonitorAssignSwapChain
    │
    ├─> 参数获取
    │   ├─> IDDCX_MONITOR MonitorObject
    │   ├─> IDARG_IN_SETSWAPCHAIN* pInArgs
    │   │   ├─> IDDCX_SWAPCHAIN hSwapChain
    │   │   ├─> LUID RenderAdapterLuid
    │   │   └─> HANDLE hNextSurfaceAvailable
    │
    └─> IndirectDeviceContext::AssignSwapChain()
        │
        ├─> 创建Direct3DDevice (使用RenderAdapterLuid)
        │   └─> Direct3DDevice(AdapterLuid).Init()
        │       ├─> DXGI Factory创建
        │       ├─> 找到对应的GPU Adapter
        │       └─> 创建D3D11设备和Context
        │
        ├─> 创建SwapChainProcessor线程
        │   └─> SwapChainProcessor(hSwapChain, Device, WdfDevice, hNextSurfaceAvailable)
        │       ├─> 保存参数
        │       ├─> 初始化URB池
        │       │   └─> usb_resouce_init()
        │       │       └─> 创建MAX_URB_SIZE个URB对象
        │       │           ├─> 分配urb_item_t结构
        │       │           ├─> WdfRequestCreate()
        │       │           ├─> 分配数据缓冲区
        │       │           └─> 插入SLIST池
        │       │
        │       ├─> 创建图像编码器
        │       │   └─> ImageEncoder(type=IMAGE_TYPE_JPG, quality=60)
        │       │
        │       ├─> 创建线程句柄
        │       │   └─> CreateThread(RunThread)
        │       └─> 启动处理循环
        │
        └─> 保存SwapChainProcessor到上下文
```

#### 阶段2: 帧抓取循环

**位置**: `SwapChainProcessor::main_function()` (Driver.cpp:432-582)

```
SwapChainProcessor::Run()
    │
    ├─> IddCxSwapChainSetDevice()
    │   └─> 设置D3D设备到SwapChain
    │
    ├─> usb_device_connect()
    │   └─> 设置g_usb_state = USB_STATE_CONNECTED
    │
    └─> for (;;)  // 无限循环,直到收到终止信号
        │
        ├─> IddCxSwapChainReleaseAndAcquireBuffer()
        │   │
        │   └─> [返回值处理]
        │       ├─> S_OK: 成功获取帧
        │       │   └─> AcquiredBuffer = ComPtr<IDXGIResource>
        │       │
        │       ├─> E_PENDING: 无新帧可用
        │       │   └─> WaitForMultipleObjects()
        │       │       ├─> WAIT_OBJECT_0: 帧可用,继续循环
        │       │       └─> WAIT_OBJECT_0+1: 终止信号,退出
        │       │
        │       └─> 其他错误: 退出循环
        │
        └─> [帧处理]  (S_OK时执行)
            │
            ├─> 检查USB连接状态
            │   └─> usb_is_connected()
            │       └─> 返回g_usb_state == USB_STATE_CONNECTED
            │
            ├─> 从URB池获取空闲URB
            │   └─> InterlockedPopEntrySList(&urb_list)
            │       └─> 返回urb_item_t*
            │
            ├─> fetch_grab_surface()  [见5.3.1]
            │   └─> 从DXGI Surface抓取帧数据到fb_buf
            │
            ├─> ImageEncoder->encode()  [见5.3.2]
            │   └─> 编码fb_buf到urb_msg
            │       └─> 添加帧头 (image_frame_header_t)
            │
            ├─> usb_send_data_async()  [见5.3.3]
            │   └─> 异步发送数据到USB设备
            │
            ├─> 性能统计更新
            │   └─> tools_perf_stats_update()
            │       ├─> 统计帧数/字节数
            │       ├─> 计算平均时间
            │       └─> 记录成功/失败
            │
            ├─> 帧率控制
            │   └─> tools_sample_tick(fps)
            │       └─> 根据目标FPS休眠
            │
            └─> 完成帧处理
                └─> IddCxSwapChainFinishedProcessingFrame()
                    └─> 通知IDDCX帧已处理,可以提供下一帧
```

#### 阶段3: DXGI Surface抓取 (fetch_grab_surface)

**位置**: `fetch_grab_surface()` (Driver.cpp:37-40)

```cpp
int fetch_grab_surface(
    std::shared_ptr<Direct3DDevice> m_Device,
    ComPtr<IDXGIResource> AcquiredBuffer,
    uint8_t *fb_buf,
    D3D11_TEXTURE2D_DESC *frameDescriptor)
{
    // 1. 获取纹理资源
    ComPtr<ID3D11Texture2D> pSurface;
    AcquiredBuffer->QueryInterface(__uuidof(ID3D11Texture2D), &pSurface);

    // 2. 获取纹理描述
    pSurface->GetDesc(frameDescriptor);

    // 3. 获取GPU上的纹理
    ComPtr<ID3D11Texture2D> stagingTexture;
    D3D11_TEXTURE2D_DESC stagingDesc = *frameDescriptor;
    stagingDesc.Usage = D3D11_USAGE_STAGING;  // CPU可访问
    stagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
    stagingDesc.BindFlags = 0;

    // 4. 创建Staging纹理
    m_Device->Device->CreateTexture2D(&stagingDesc, NULL, &stagingTexture);

    // 5. 从GPU复制到CPU可访问的Staging纹理
    m_Device->DeviceContext->CopyResource(stagingTexture.Get(), pSurface.Get());

    // 6. 映射纹理到CPU内存
    D3D11_MAPPED_SUBRESOURCE mappedResource;
    m_Device->DeviceContext->Map(stagingTexture.Get(), 0,
                                D3D11_MAP_READ, 0, &mappedResource);

    // 7. 复制数据到帧缓冲区(fb_buf)
    uint8_t* pSrc = (uint8_t*)mappedResource.pData;
    uint32_t srcPitch = mappedResource.RowPitch;

    for (int row = 0; row < frameDescriptor->Height; row++) {
        memcpy(fb_buf + row * frameDescriptor->Width * 4,
               pSrc + row * srcPitch,
               frameDescriptor->Width * 4);
    }

    // 8. 解除映射
    m_Device->DeviceContext->Unmap(stagingTexture.Get(), 0);

    return 0;
}
```

**数据流程**:
```
DXGI Surface (GPU显存)
    ↓ CopyResource()
Staging Texture (GPU显存, CPU可读)
    ↓ Map()
CPU可见内存
    ↓ memcpy()
fb_buf[] (帧缓冲区)
```

#### 阶段4: 图像编码

**位置**: `ImageEncoder::encode()` (encoder.cpp)

```cpp
int ImageEncoder::encode(
    uint8_t* output,
    const uint8_t* input,
    int buffer_size,
    int x, int y,
    int width, int height)
{
    // 编码帧头
    image_frame_header_t header;
    header.magic_id = FRAME_MAGIC_ID;  // 0x6C76736E
    header.img_type = m_type;         // IMAGE_TYPE_JPG = 3
    header.img_len = 0;              // 暂时0,后面填充
    header.img_cnt = m_counter++;      // 帧计数

    // 写入帧头 (16字节)
    int pos = 0;
    memcpy(output + pos, &header, sizeof(header));
    pos += sizeof(header);

    // 根据类型编码
    if (m_type == IMAGE_TYPE_JPG) {
        int jpeg_len = encode_jpeg(output + pos, input, buffer_size,
                                 x, y, width, height);
        header.img_len = jpeg_len;
        // 重新写入帧头(修正img_len)
        memcpy(output, &header, sizeof(header));
        pos += jpeg_len;
    }
    else if (m_type == IMAGE_TYPE_RGB565) {
        int rgb565_len = encode_rgb565(output + pos, input, buffer_size,
                                       x, y, width, height);
        header.img_len = rgb565_len;
        memcpy(output, &header, sizeof(header));
        pos += rgb565_len;
    }
    else if (m_type == IMAGE_TYPE_RGB888) {
        int rgb888_len = encode_rgb888(output + pos, input, buffer_size,
                                       x, y, width, height);
        header.img_len = rgb888_len;
        memcpy(output, &header, sizeof(header));
        pos += rgb888_len;
    }

    return pos;  // 总数据长度
}
```

**JPEG编码示例**:
```cpp
int ImageEncoder::encode_jpeg(
    uint8_t* output,
    const uint8_t* input,
    int buffer_size,
    int x, int y, int width, int height)
{
    // 1. 初始化JPEG编码器
    jpeg_compress_struct& cinfo = m_jpeg_private->cinfo;
    jpeg_create_compress(&cinfo);

    // 2. 设置图像参数
    cinfo.image_width = width;
    cinfo.image_height = height;
    cinfo.input_components = 3;  // RGB
    cinfo.in_color_space = JCS_RGB;
    cinfo.data_precision = 8;

    // 3. 设置输出缓冲区
    jpeg_mem_dest(&cinfo, output, buffer_size);

    // 4. 设置压缩质量
    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, m_quality, TRUE);

    // 5. 开始压缩
    jpeg_start_compress(&cinfo, TRUE);

    // 6. 逐行压缩
    JSAMPROW row_pointer[1];
    int row_stride = width * 3;  // RGB888 = 3字节/像素

    while (cinfo.next_scanline < cinfo.image_height) {
        // 转换BGRA到RGB
        const uint32_t* src = (const uint32_t*)(input +
                                         cinfo.next_scanline * width * 4);
        uint8_t* dst = m_jpeg_private->row_buffer;

        for (int col = 0; col < width; col++) {
            uint32_t pixel = src[col];
            dst[col * 3 + 0] = (pixel >> 16) & 0xFF;  // R
            dst[col * 3 + 1] = (pixel >> 8) & 0xFF;   // G
            dst[col * 3 + 2] = pixel & 0xFF;         // B
        }

        row_pointer[0] = m_jpeg_private->row_buffer;
        jpeg_write_scanlines(&cinfo, row_pointer, 1);
    }

    // 7. 结束压缩
    jpeg_finish_compress(&cinfo);

    int jpeg_size = cinfo.dest->pub.next_output_byte -
                   cinfo.dest->buffer;
    jpeg_destroy_compress(&cinfo);

    return jpeg_size;
}
```

#### 阶段5: USB异步传输

**位置**: `usb_send_data_async()` (usb_driver.cpp:45-90)

```cpp
NTSTATUS usb_send_data_async(urb_item_t* urb, WDFUSBPIPE pipe, int tsize)
{
    // 1. 验证缓冲区
    if (urb->wdfMemory == NULL) {
        return STATUS_INVALID_DEVICE_STATE;
    }

    if (tsize > urb->urb_msg_size) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // 2. 复制数据到WDF内存对象
    WdfMemoryCopyFromBuffer(urb->wdfMemory, 0, urb->urb_msg, tsize);

    // 3. 格式化写请求
    status = WdfUsbTargetPipeFormatRequestForWrite(
        pipe,
        urb->Request,        // WDFREQUEST对象
        urb->wdfMemory,     // 包含数据的WDF内存对象
        NULL               // 偏移量(默认0)
    );

    // 4. 设置完成回调
    WdfRequestSetCompletionRoutine(
        urb->Request,
        EvtRequestWriteCompletionRoutine,  // 回调函数
        urb                               // 上下文
    );

    // 5. 发送请求(异步)
    BOOL sendResult = WdfRequestSend(
        urb->Request,
        WdfUsbTargetPipeGetIoTarget(pipe),
        WDF_NO_SEND_OPTIONS  // 无特殊选项,异步发送
    );

    if (!sendResult) {
        // 发送失败,获取状态
        status = WdfRequestGetStatus(urb->Request);
        return status;
    }

    return STATUS_SUCCESS;  // 请求已异步发送
}
```

**完成回调**:
```cpp
VOID EvtRequestWriteCompletionRoutine(
    WDFREQUEST Request,
    WDFIOTARGET Target,
    PWDF_REQUEST_COMPLETION_PARAMS CompletionParams,
    WDFCONTEXT Context)
{
    urb_item_t* urb = (urb_item_t*)Context;

    // 1. 获取传输状态
    NTSTATUS status = CompletionParams->IoStatus.Status;

    // 2. 获取传输字节数
    PWDF_USB_REQUEST_COMPLETION_PARAMS usbParams =
        CompletionParams->Parameters.Usb.Completion;
    size_t bytesWritten = usbParams->Parameters.PipeWrite.Length;

    if (!NT_SUCCESS(status)) {
        LOGE("Write failed: Status 0x%x, UsbdStatus 0x%x\n",
              status, usbParams->UsbdStatus);
    }

    // 3. 将URB放回池中(无锁的原子操作)
    InterlockedPushEntrySList(urb->urb_list, &(urb->node));

    LOGI("URB id=%d returned to pool, bytesWritten=%d\n",
          urb->id, bytesWritten);
}
```

### 5.4 完整数据流

```
Windows桌面 (DXGI Surface)
    │
    ├─> Direct3D渲染 (GPU)
    │
    ├─> DXGI SwapChain
    │
    ├─> IDDCX回调
    │   └─> IddCxSwapChainReleaseAndAcquireBuffer()
    │
    ├─> 获取Surface (IDXGIResource)
    │
    ├─> GPU复制 (CopyResource)
    │   └─> SwapChain → Staging Texture
    │
    ├─> GPU映射 (Map)
    │   └─> Staging Texture → CPU内存
    │
    ├─> CPU复制 (memcpy)
    │   └─> CPU内存 → fb_buf[]
    │       格式: BGRA (32位/像素)
    │
    ├─> 图像编码 (libjpeg-turbo)
    │   ├─> BGRA → RGB转换
    │   ├─> 添加帧头 (16字节)
    │   └─> JPEG压缩
    │       格式: [帧头][JPEG数据]
    │
    ├─> USB传输 (URB)
    │   ├─> 复制到urb_msg缓冲区
    │   ├─> 格式化USB请求
    │   ├─> 设置完成回调
    │   └─> 异步发送
    │
    ├─> USB设备
    │   └─> Bulk OUT Pipe
    │
    └─> 外部显示设备
        └─> 解码并显示
```

---

## 6. 函数调用顺序

### 6.1 驱动初始化阶段

```
DriverEntry()
    ├─> registry_config_base()
    │   └─> 从注册表读取配置
    │
    ├─> WDF_DRIVER_CONFIG_INIT()
    │
    └─> WdfDriverCreate()

IddSampleDeviceAdd()
    ├─> WDF_PNPPOWER_EVENT_CALLBACKS_INIT()
    │   └─> 注册Power/PnP回调
    │       ├─> EvtDeviceD0Entry
    │       ├─> EvtDevicePrepareHardware
    │       ├─> EvtDeviceReleaseHardware
    │       └─> EvtDeviceSurpriseRemoval
    │
    ├─> IDD_CX_CLIENT_CONFIG_INIT()
    │   └─> 注册IDDCX回调
    │       ├─> EvtIddCxAdapterInitFinished
    │       ├─> EvtIddCxParseMonitorDescription
    │       ├─> EvtIddCxMonitorGetDefaultDescriptionModes
    │       ├─> EvtIddCxMonitorQueryTargetModes
    │       ├─> EvtIddCxAdapterCommitModes
    │       ├─> EvtIddCxMonitorAssignSwapChain
    │       └─> EvtIddCxMonitorUnassignSwapChain
    │
    ├─> IddCxDeviceInitConfig()
    │
    ├─> WdfDeviceCreate()
    │
    ├─> IndirectDeviceContext(Device)
    │   ├─> 初始化配置默认值
    │   └─> CreateMonitor(0)
    │       ├─> IddCxMonitorCreate()
    │       └─> IddCxMonitorArrival()
    │
    └─> IddCxDeviceInitialize()

IddSampleAdapterInitFinished()
    └─> IddCxAdapterInitAsync()
```

### 6.2 USB设备初始化阶段

```
IddSampleDeviceD0Entry()
    └─> 进入D0状态(设备启动)

IddSampleDevicePrepareHardware()
    │
    ├─> WdfUsbTargetDeviceCreateWithParameters()
    │   └─> 创建USB设备对象
    │
    ├─> usb_get_discribe_info()
    │   ├─> WdfUsbTargetDeviceGetDeviceDescriptor()
    │   │   └─> 获取VID/PID
    │   │
    │   └─> WdfUsbTargetDeviceQueryString()
    │       └─> 获取产品字符串
    │
    └─> usb_select_interface()
        ├─> WdfUsbTargetDeviceGetNumInterfaces()
        │
        ├─> for (each interface)
        │   ├─> WdfUsbTargetDeviceGetInterface()
        │   ├─> WdfUsbInterfaceGetNumConfiguredPipes()
        │   └─> for (each pipe)
        │       ├─> WdfUsbInterfaceGetConfiguredPipe()
        │       ├─> 检查管道类型
        │       └─> 保存Bulk IN/OUT管道
        │
        └─> 返回BulkReadPipe和BulkWritePipe
```

### 6.3 显示器创建阶段

```
用户扩展桌面到虚拟显示器
    │
    └─> Windows创建虚拟显示器
        │
        └─> IddCx触发回调
            │
            ├─> IddSampleParseMonitorDescription()
            │   └─> 返回EDID和模式
            │
            ├─> IddSampleMonitorQueryModes()
            │   └─> 返回支持的目标模式
            │       ├─> 1920x1080@60
            │       ├─> 1280x720@60
            │       └─> ...
            │
            └─> IddSampleAdapterCommitModes()
                └─> 模式确认
                    │
                    └─> IddSampleMonitorAssignSwapChain()
                        └─> 分配SwapChain
                            │
                            ├─> Direct3DDevice(AdapterLuid).Init()
                            │   ├─> DXGI Factory创建
                            │   ├─> 查找GPU Adapter
                            │   └─> 创建D3D11设备
                            │
                            ├─> SwapChainProcessor构造
                            │   ├─> usb_resouce_init()
                            │   │   └─> 创建URB池(MAX_URB_SIZE=5)
                            │   │       ├─> 分配urb_item_t
                            │   │       ├─> WdfRequestCreate()
                            │   │       ├─> 分配urb_msg缓冲区
                            │   │       └─> 插入SLIST
                            │   │
                            │   ├─> ImageEncoder构造
                            │   │   └─> 初始化JPEG编码器
                            │   │
                            │   └─> CreateThread(RunThread)
                            │       └─> 启动处理线程
                            │
                            └─> SwapChainProcessor::Run()
                                ├─> IddCxSwapChainSetDevice()
                                ├─> usb_device_connect()
                                └─> 进入主循环
```

### 6.4 帧处理循环(单帧)

```
SwapChainProcessor::main_function()  [无限循环]
    │
    ├─> IddCxSwapChainReleaseAndAcquireBuffer()
    │   │
    │   ├─> [返回 S_OK]
    │   │   └─> AcquiredBuffer = IDXGIResource
    │   │
    │   └─> [返回 E_PENDING]
    │       └─> WaitForMultipleObjects()
    │           ├─> 等待m_hAvailableBufferEvent
    │           └─> 等待m_hTerminateEvent
    │
    ├─> usb_is_connected()
    │   └─> 检查g_usb_state == USB_STATE_CONNECTED
    │
    ├─> InterlockedPopEntrySList(&urb_list)
    │   └─> 从URB池获取空闲URB
    │
    ├─> fetch_grab_surface()
    │   ├─> QueryInterface(ID3D11Texture2D)
    │   ├─> GetDesc(&frameDescriptor)
    │   ├─> CreateTexture2D(Staging)
    │   ├─> CopyResource(SwapChain → Staging)
    │   ├─> Map(Staging)
    │   ├─> memcpy(CPU内存 → fb_buf)
    │   └─> Unmap(Staging)
    │
    ├─> m_pEncoder->encode()
    │   ├─> 准备帧头 (image_frame_header_t)
    │   ├─> JPEG编码 (libjpeg-turbo)
    │   └─> 返回编码后大小
    │
    ├─> usb_send_data_async()
    │   ├─> WdfMemoryCopyFromBuffer()
    │   ├─> WdfUsbTargetPipeFormatRequestForWrite()
    │   ├─> WdfRequestSetCompletionRoutine()
    │   └─> WdfRequestSend()
    │       └─> 异步发送,立即返回
    │
    ├─> tools_perf_stats_update()
    │   └─> 更新性能统计
    │
    ├─> tools_sample_tick(fps)
    │   └─> FPS控制休眠
    │
    └─> IddCxSwapChainFinishedProcessingFrame()
        └─> 通知IDDCX帧已完成
            └─> [循环继续,等待下一帧]
```

### 6.5 USB完成回调

```
USB传输完成
    │
    └─> WDF调用完成回调
        └─> EvtRequestWriteCompletionRoutine()
            │
            ├─> 获取状态
            │   ├─> CompletionParams->IoStatus.Status
            │   └─> usbParams->UsbdStatus
            │
            ├─> 获取传输字节数
            │   └─> usbParams->Parameters.PipeWrite.Length
            │
            ├─> 检查错误
            │   └─> if (!NT_SUCCESS(status))
            │       └─> LOGE()
            │
            └─> 归还URB到池
                └─> InterlockedPushEntrySList(urb->urb_list, &(urb->node))
                    └─> 原子操作,无需锁
```

### 6.6 设备断开阶段

```
USB设备拔出
    │
    └─> IddSampleDeviceSurpriseRemoval()
        ├─> 设置g_usb_state = USB_STATE_DISCONNECTED
        │
        └─> IddSampleMonitorUnassignSwapChain()
            └─> SwapChainProcessor析构
                ├─> 设置终止事件
                │   └─> SetEvent(m_hTerminateEvent)
                │
                ├─> 等待线程结束
                │   └─> WaitForSingleObject(m_hThread)
                │
                ├─> 销毁URB池
                │   └─> usb_resouce_distory()
                │       ├─> 删除所有URB对象
                │       ├─> WdfObjectDelete(Request)
                │       └─> 释放urb_msg缓冲区
                │
                └─> 销毁编码器
                    └─> ~ImageEncoder()
```

---

## 7. 数据流程

### 7.1 帧数据结构

```
原始帧 (DXGI Surface)
├─ 格式: DXGI_FORMAT_B8G8R8A8_UNORM
├─ 布局: BGRA (32位/像素)
├─ 大小: 1920×1080 = 2,073,600 像素
└─ 字节数: 8,294,400 字节 (约8MB)

↓ [fetch_grab_surface]

帧缓冲区 (fb_buf[])
├─ 格式: BGRA数组
├─ 大小: DISP_MAX_HEIGHT×DISP_MAX_WIDTH×4
├─ 内容: [B0,G0,R0,A0, B1,G1,R1,A1, ...]
└─ 字节数: 8,294,400 字节

↓ [ImageEncoder::encode]

编码后数据 (urb_msg[])
├─ [0:15]  帧头 (16字节)
│   ├─ magic_id: 0x6C76736E ('lvsn')
│   ├─ img_type: 3 (JPEG)
│   ├─ img_len: JPEG数据长度
│   └─ img_cnt: 帧计数
├─ [16:END] JPEG数据
│   └─ 压缩率: 约10:1 ~ 30:1
└─ 总大小: 约150KB ~ 800KB (取决于质量和分辨率)

↓ [usb_send_data_async]

USB传输包
├─ USB Header (USB协议)
├─ 帧头 (16字节)
└─ JPEG数据 (分包传输)
    └─ 每包最大: max_out_pkg_size (通常512或1024字节)
```

### 7.2 URB池机制

```
初始化 (usb_resouce_init)
    │
    ├─> InitializeSListHead(&urb_list)
    │
    └─> for (i = 0; i < MAX_URB_SIZE; i++)
        ├─> 分配urb_item_t
        │   └─> _aligned_malloc(sizeof(urb_item_t), ...)
        ├─> WdfRequestCreate(&purb->Request, ...)
        ├─> 分配urb_msg缓冲区
        │   └─> _aligned_malloc(max_transfer_size, ...)
        └─> 插入池
            └─> InterlockedPushEntrySList(urb_list, &purb->node)

运行时
    │
    ├─> [发送帧]
    │   ├─> InterlockedPopEntrySList(&urb_list)
    │   │   └─> 获取空闲URB
    │   ├─> 填充数据
    │   ├─> usb_send_data_async()
    │   └─> [URB异步发送中...]
    │
    └─> [传输完成]
        ├─> EvtRequestWriteCompletionRoutine()
        ├─> 归还URB
        └─> InterlockedPushEntrySList(urb_list, &purb->node)
            └─> 重新加入池,可复用

URB池状态
    ├─> 空闲URB: 可立即分配
    ├─> 使用中URB: 正在异步传输
    └─> 池大小: MAX_URB_SIZE (默认5)
```

### 7.3 性能统计更新

```
tools_perf_stats_update(stats, frame_size, grab_time, encode_time, send_time, success)
    │
    ├─> stats->total_frames++
    ├─> stats->total_bytes += frame_size
    │
    ├─> if (success)
    │   └─> stats->urbs_sent++
    │   else
    │   ├─> stats->urbs_failed++
    │   └─> stats->error_frames++
    │
    ├─> 更新平均时间 (指数移动平均)
    │   ├─> avg_grab_time_us = (avg * (n-1) + grab) / n
    │   ├─> avg_encode_time_us = (avg * (n-1) + encode) / n
    │   ├─> avg_send_time_us = (avg * (n-1) + send) / n
    │   └─> avg_total_time_us = avg_grab + avg_encode + avg_send
    │
    └─> 定期打印 (每1000帧)
        └─> tools_perf_stats_print()
            ├─> 总帧数: 1000
            ├─> 总字节: XXX MB
            ├─> 丢弃帧: XX
            ├─> 错误帧: XX
            ├─> URB发送: XXX
            ├─> URB失败: XX
            ├─> 平均抓取: XXX us
            ├─> 平均编码: XXX us
            ├─> 平均发送: XXX us
            └─> 平均总时间: XXX us
```

---

## 8. 错误处理机制

### 8.1 USB连接状态管理

```cpp
typedef enum _usb_connection_state {
    USB_STATE_CONNECTED = 0,      // 正常连接
    USB_STATE_DISCONNECTED = 1,   // 已断开
    USB_STATE_ERROR = 2,          // 传输错误
    USB_STATE_RECOVERING = 3      // 恢复中
} usb_connection_state_t;

// 全局状态
static usb_connection_state_t g_usb_state;
static WDFWAITLOCK g_usb_state_lock;
```

**状态转换**:
```
[正常] USB_STATE_CONNECTED
    │
    ├─> USB传输失败 (错误计数达到阈值)
    │   └─> USB_STATE_ERROR
    │
    └─> USB设备移除
        └─> USB_STATE_DISCONNECTED

[错误] USB_STATE_ERROR
    │
    └─> 尝试恢复
        ├─> 成功 → USB_STATE_CONNECTED
        └─> 失败 → USB_STATE_DISCONNECTED

[断开] USB_STATE_DISCONNECTED
    │
    └─> 设备重新插入
        └─> USB_STATE_CONNECTED
```

### 8.2 错误处理流程

#### 传输错误处理

```cpp
// usb_send_data_async失败
if (!NT_SUCCESS(status)) {
    LOGW("USB send failed with status 0x%x, attempting recovery\n", status);

    // 错误恢复策略
    switch (error_recovery_strategy) {
        case RECOVERY_RETRY:
            // 立即重试
            break;
        case RECOVERY_RESET:
            // 重置USB管道
            WdfUsbTargetPipeAbortSynchronously(pipe);
            break;
        case RECOVERY_REINIT:
            // 重新初始化USB设备
            usb_device_disconnect();
            usb_device_connect();
            break;
    }
}
```

#### 完成回调错误处理

```cpp
VOID EvtRequestWriteCompletionRoutine(...)
{
    status = CompletionParams->IoStatus.Status;

    if (!NT_SUCCESS(status)) {
        LOGE("Write failed: Status 0x%x, UsbdStatus 0x%x\n",
              status, usbCompletionParams->UsbdStatus);

        // 增加错误计数
        InterlockedIncrement(&g_usb_error_count);

        // 检查是否达到阈值
        if (g_usb_error_count >= USB_ERROR_RESET_THRESHOLD) {
            WdfWaitLockAcquire(g_usb_state_lock, NULL);
            g_usb_state = USB_STATE_ERROR;
            WdfWaitLockRelease(g_usb_state_lock);

            LOGE("USB error threshold reached, state set to ERROR\n");
        }
    } else {
        // 成功,重置错误计数
        InterlockedExchange(&g_usb_error_count, 0);
    }

    // 无论如何,归还URB到池
    InterlockedPushEntrySList(urb->urb_list, &(urb->node));
}
```

### 8.3 热插拔处理

```cpp
EVT_WDF_DEVICE_SURPRISE_REMOVAL IddSampleDeviceSurpriseRemoval(
    WDFDEVICE Device)
{
    auto* pContext = WdfObjectGet_IndirectDeviceContextWrapper(Device);

    LOGI("Device surprise removal detected\n");

    // 设置断开状态
    usb_device_disconnect(Device);

    // IDDCX会自动调用UnassignSwapChain
    // SwapChainProcessor会收到终止信号并清理资源

    return STATUS_SUCCESS;
}
```

---

## 附录A: 配置参数

### 注册表配置位置

```
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IddSampleDriver\Parameters
```

### 可配置参数

| 参数名 | 类型 | 默认值 | 说明 |
|-------|------|--------|------|
| debug_level | DWORD | 4 | 日志级别 (0-4) |
| width | DWORD | 1920 | 显示宽度 |
| height | DWORD | 1080 | 显示高度 |
| img_type | DWORD | 3 (JPEG) | 编码类型 (0=RGB565, 1=RGB888, 3=JPEG) |
| img_qlt | DWORD | 60 | JPEG质量 (0-100) |
| fps | DWORD | 30 | 目标帧率 |
| sleep | DWORD | 0 | 调试休眠时间(毫秒) |
| blimit | DWORD | 0 | 缓冲区限制 |

---

## 附录B: 性能优化建议

### 带宽优化

| 分辨率 | RGB888未压缩 | JPEG 60质量 | JPEG 80质量 |
|---------|-------------|------------|------------|
| 1920×1080 | ~6.2 MB/frame | ~150 KB/frame | ~300 KB/frame |
| 1280×720 | ~2.7 MB/frame | ~80 KB/frame | ~160 KB/frame |
| 800×600 | ~1.4 MB/frame | ~40 KB/frame | ~80 KB/frame |

**推荐配置**:
- ACM全速(12 Mbps): 800×600@15fps, JPEG 40-60质量
- ACM高速(480 Mbps): 1280×720@30fps, JPEG 60-80质量

### URB池大小

```
低配置: MAX_URB_SIZE = 3
中配置: MAX_URB_SIZE = 5 (默认)
高配置: MAX_URB_SIZE = 10
```

---

## 附录C: 故障排查

### 常见错误码

| 错误码 | 含义 | 可能原因 |
|--------|------|---------|
| 0xC0000001 (STATUS_UNSUCCESSFUL) | 操作失败 | USB设备响应异常 |
| 0xC00000B5 (STATUS_IO_TIMEOUT) | I/O超时 | USB设备无响应 |
| 0xC0000120 (STATUS_CANCELLED) | 操作取消 | USB管道忙或设备移除 |
| 0xC0000185 (STATUS_IO_DEVICE_ERROR) | 设备错误 | USB硬件故障 |

### 调试技巧

1. **启用详细日志**
   ```cpp
   debug_level = LOG_LEVEL_TRACE;  // 输出所有日志
   ```

2. **使用DebugView**
   - 设置: Capture → Enable Verbose Kernel Output
   - 过滤: `[INFO] usb_`

3. **检查URB池状态**
   ```cpp
   LOGI("URB available: %d / %d\n",
         urb_available_count, MAX_URB_SIZE);
   ```

4. **性能分析**
   - 检查avg_grab_time_us (应该 < 5000μs)
   - 检查avg_encode_time_us (JPEG通常 < 10000μs)
   - 检查avg_send_time_us (应该 < 1000μs)

---

## 附录D: 参考资料

### Microsoft文档
- [win10_idd_xfz1986_usb_graphic_driver_display](https://github.com/chuanjinpang/win10_idd_xfz1986_usb_graphic_driver_display.git)
- [Indirect Display Driver Model Overview](https://docs.microsoft.com/en-us/windows-hardware/drivers/display/indirect-display-driver-model-overview)
- [UMDF 2.0 Programming Guide](https://docs.microsoft.com/en-us/windows-hardware/drivers/wdf/getting-started-with-umdf-2)
- [WDF USB Reference](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdfusb/)

### USB规范

- USB 2.0 Specification
- USB CDC 1.2 Specification (ACM设备)

### 图像编码

- libjpeg-turbo Documentation
- JPEG File Interchange Format (JFIF)

---

**文档版本**: v1.0
**最后更新**: 2026-02-02
**作者**: mrsha1195@163.com
