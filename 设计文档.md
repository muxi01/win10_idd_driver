# IDD USB Graphic Driver 详细设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 项目名称 | IDD USB Graphic Driver |
| 版本 | v1.0 |
| 驱动类型 | Windows Indirect Display Driver (IDD) + UMDF |
| 开发环境 | Visual Studio 2022, Windows SDK 10.0.26100.0 |
| 目标平台 | Windows 10/11 x64 |
| 作者 | Microsoft / Modified |

---

## 目录

1. [系统概述](#系统概述)
2. [架构设计](#架构设计)
3. [核心模块详解](#核心模块详解)
4. [数据流程](#数据流程)
5. [接口设计](#接口设计)
6. [配置管理](#配置管理)
7. [错误处理](#错误处理)
8. [性能优化](#性能优化)
9. [编译与部署](#编译与部署)

---

## 系统概述

### 1.1 项目简介

IDD USB Graphic Driver 是一个 Windows 间接显示驱动程序，通过 USB 将 Windows 桌面显示数据实时传输到外部显示设备。驱动程序基于 Microsoft Indirect Display Driver (IDD) 框架，采用用户模式驱动框架 (UMDF) 实现。

### 1.2 核心功能

- **虚拟显示器**：创建一个可配置的虚拟显示器（最大支持 1920x1080）
- **图像编码**：支持多种编码格式（RGB565、RGB888、JPEG）
- **USB 传输**：通过 USB Bulk 管道异步传输图像数据
- **帧率控制**：支持自定义帧率（默认 60 FPS）
- **错误恢复**：完善的 USB 错误检测和自动恢复机制
- **性能监控**：详细的性能统计和日志记录

### 1.3 技术栈

| 组件 | 技术 |
|------|------|
| 驱动框架 | UMDF 2.0 |
| 显示驱动 | IDDCX (Indirect Display Class Extension) |
| 图形 API | DirectX 11 (DXGI 1.5, D3D11_2) |
| JPEG 编码 | libjpeg-turbo (静态库) |
| USB 通信 | WDFUSB |
| 智能指针 | Microsoft WRL (Windows Runtime Library) |

---

## 架构设计

### 2.1 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     Windows OS Layer                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │   Desktop    │  │   DXGI       │  │   IDDCX      │       │
│  │ Composition  │  │  SwapChain   │  │   Framework  │       │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘       │
└─────────┼──────────────────┼──────────────────┼──────────────┘
          │                  │                  │
┌─────────┼──────────────────┼──────────────────┼──────────────┐
│         ▼                  ▼                  ▼              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │           IddSampleDriver (UMDF Driver)              │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌────────────┐ │  │
│  │  │ DriverEntry  │  │Device Context│  │SwapChain   │ │  │
│  │  │ & Callbacks  │  │              │  │Processor   │ │  │
│  │  └──────┬───────┘  └──────┬───────┘  └─────┬──────┘ │  │
│  │         │                 │                │         │  │
│  │  ┌──────▼───────┐  ┌──────▼───────┐  ┌────▼─────┐  │  │
│  │  │USB Driver    │  │Image Encoder │  │Tools     │  │  │
│  │  │Module        │  │Module        │  │Module    │  │  │
│  │  └──────┬───────┘  └──────┬───────┘  └────┬─────┘  │  │
│  └─────────┼──────────────────┼──────────────────┼────────┘
│            │                  │                  │
│  ┌─────────▼──────────────────▼──────────────────▼────────┐
│  │              libjpeg-turbo (JPEG Library)              │
│  └──────────────────────────────────────────────────────────┘
└────────────────────────────────────────────────────────────┘
                            │
                            ▼ USB Bulk Pipe
┌─────────────────────────────────────────────────────────────┐
│                   External USB Device                       │
│              (Display Controller / FPGA)                   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

```
IddSampleDriver/
├── Driver.cpp/h           # 驱动主逻辑和 IDDCX 回调
├── usb_driver.cpp/h       # USB 设备管理和数据传输
├── image_encoder.c/h      # 图像编码器（RGB565/RGB888/JPEG）
├── tools.c/h              # 工具函数（日志、时间、统计）
├── basetype.h             # 基础类型定义和常量
├── Trace.h                # WPP 追踪定义
└── IddSampleDriver.inf    # 驱动安装文件
```

### 2.3 初始化流程
```
DriverEntry()
  └─ registry_config_base() 

IddSampleDeviceAdd()
  └─ WdfDeviceCreate()

[Windows PnP 调用]
  └─ IddSampleDevicePrepareHardware()
      └─ SelectInterfaces()

[IddCx 内部调用]
  └─ IddCxAdapterInitAsync()
      └─ IddSampleAdapterInitFinished()
          └─ FinishInit()
              └─ CreateMonitor()
                  └─ IddCxMonitorCreate()
                  └─ IddCxMonitorArrival()
                      └─ [IddCx 内部]
                          └─ IddSampleParseMonitorDescription() 

```
---

## 核心模块详解

### 3.1 驱动入口 (Driver.cpp)

#### 3.1.1 DriverEntry

驱动程序入口点，负责初始化 WDF 框架和注册设备回调。

```cpp
NTSTATUS DriverEntry(
    PDRIVER_OBJECT  pDriverObject,
    PUNICODE_STRING pRegistryPath
)
```

**功能**：
1. 加载注册表配置（debug_level）
2. 初始化 WDF 驱动配置
3. 注册 `IddSampleDeviceAdd` 回调
4. 创建 WDF 驱动对象

**关键代码**：
```cpp
WDF_DRIVER_CONFIG_INIT(&Config, IddSampleDeviceAdd);
WdfDriverCreate(pDriverObject, pRegistryPath, &Attributes, &Config, WDF_NO_HANDLE);
```

#### 3.1.2 IddSampleDeviceAdd

创建 WDF 设备对象和设备上下文。

```cpp
NTSTATUS IddSampleDeviceAdd(WDFDRIVER Driver, PWDFDEVICE_INIT pDeviceInit)
```

**功能**：
1. 注册 PnP/Power 回调（D0Entry、PrepareHardware、ReleaseHardware、SurpriseRemoval）
2. 配置 IDDCX 客户端回调
3. 创建 WDF 设备对象
4. 创建 `IndirectDeviceContextWrapper` 设备上下文
5. 初始化 IDDCX 设备

**IDDCX 回调注册**：
| 回调 | 功能 |
|------|------|
| `EvtIddCxAdapterInitFinished` | 适配器初始化完成 |
| `EvtIddCxParseMonitorDescription` | 解析监视器描述 |
| `EvtIddCxMonitorGetDefaultDescriptionModes` | 获取默认显示模式 |
| `EvtIddCxMonitorQueryModes` | 查询支持的模式 |
| `EvtIddCxAdapterCommitModes` | 提交显示模式 |
| `EvtIddCxMonitorAssignSwapChain` | 分配 SwapChain |
| `EvtIddCxMonitorUnassignSwapChain` | 释放 SwapChain |

#### 3.1.3 注册表配置

从注册表加载驱动配置：

```cpp
VOID registry_config_base(void)
{
    const LPCTSTR REGISTRY_PATH = TEXT("SYSTEM\\CurrentControlSet\\Services\\IddSampleDriver\\Parameters");
    // 读取 debug_level 配置
}
```

**注册表路径**：
```
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IddSampleDriver\Parameters
```

**配置项**：
- `debug_level`：日志级别（0-4）

---

### 3.2 设备上下文 (Driver.h)

#### 3.2.1 Direct3DDevice

管理 Direct3D 渲染设备。

```cpp
struct Direct3DDevice {
    LUID AdapterLuid;
    ComPtr<IDXGIFactory5> DxgiFactory;
    ComPtr<IDXGIAdapter1> Adapter;
    ComPtr<ID3D11Device> Device;
    ComPtr<ID3D11DeviceContext> DeviceContext;
    
    HRESULT Init();
};
```

**功能**：
- 创建 DXGI Factory
- 枚举并选择 GPU 适配器
- 创建 D3D11 设备和设备上下文

#### 3.2.2 SwapChainProcessor

帧处理核心线程，负责从 SwapChain 获取帧数据、编码和发送。

```cpp
class SwapChainProcessor {
public:
    SwapChainProcessor(IDDCX_SWAPCHAIN hSwapChain, 
                      std::shared_ptr<Direct3DDevice> Device, 
                      WDFDEVICE WdfDevice, 
                      HANDLE NewFrameEvent);
    ~SwapChainProcessor();
    
private:
    static DWORD CALLBACK RunThread(LPVOID Argument);
    void Run();
    void RunCore();
    void decision_runtime_encoder(WDFDEVICE Device);
    
public:
    IDDCX_SWAPCHAIN m_hSwapChain;
    std::shared_ptr<Direct3DDevice> m_Device;
    WDFDEVICE mp_WdfDevice;
    uint8_t fb_buf[DISP_MAX_HEIGHT * DISP_MAX_WIDTH * 4];
    
    image_encoder_t *encoder;
    SLIST_HEADER urb_list;
    int max_out_pkg_size;
    
    HANDLE m_hAvailableBufferEvent;
    Microsoft::WRL::Wrappers::Thread m_hThread;
    Microsoft::WRL::Wrappers::Event m_hTerminateEvent;
};
```

**关键成员**：

| 成员 | 类型 | 说明 |
|------|------|------|
| `fb_buf` | `uint8_t[]` | 帧缓冲区（1920x1080x4 = ~8MB） |
| `encoder` | `image_encoder_t*` | 当前编码器实例 |
| `urb_list` | `SLIST_HEADER` | URB 队列头 |
| `m_hThread` | `Thread` | 处理线程句柄 |
| `m_hAvailableBufferEvent` | `HANDLE` | 新帧可用事件 |

**处理流程**：
1. 等待 `m_hAvailableBufferEvent` 信号（新帧可用）
2. 调用 `IddCxSwapChainReleaseAndAcquireBuffer()` 获取帧
3. 检查 USB 连接状态
4. 从 URB 队列获取空闲 URB
5. 调用 `enc_grab_surface()` 复制帧数据到 `fb_buf`
6. 调用 `encoder->encode()` 编码图像
7. 调用 `encoder->encode_header()` 添加帧头
8. 调用 `usb_send_msg_async()` 异步发送数据
9. 更新性能统计
10. 调用 `IddCxSwapChainFinishedProcessingFrame()` 完成帧处理

#### 3.2.3 IndirectDeviceContext

间接显示设备上下文，管理适配器和监视器。

```cpp
class IndirectDeviceContext {
public:
    IndirectDeviceContext(_In_ WDFDEVICE WdfDevice);
    virtual ~IndirectDeviceContext();
    
    void InitAdapter();
    void FinishInit();
    void CreateMonitor(unsigned int index);
    void AssignSwapChain(IDDCX_SWAPCHAIN SwapChain, LUID RenderAdapter, HANDLE NewFrameEvent);
    void UnassignSwapChain();
    
protected:
    WDFDEVICE m_WdfDevice;
    IDDCX_ADAPTER m_Adapter;
    IDDCX_MONITOR m_Monitor;
    std::unique_ptr<SwapChainProcessor> m_ProcessingThread;
    
public:
    static const DISPLAYCONFIG_VIDEO_SIGNAL_INFO s_KnownMonitorModes[];
    static const BYTE s_KnownMonitorEdid[];
};
```

**已知显示模式**：
- 1920x1080 @ 60Hz
- 1280x720 @ 60Hz
- 1024x768 @ 60Hz
- 800x600 @ 60Hz
- 640x480 @ 60Hz

#### 3.2.4 IndirectDeviceContextWrapper

WDF 设备上下文包装器，存储设备特定信息。

```cpp
class IndirectDeviceContextWrapper {
public:
    Microsoft::IndirectDisp::IndirectDeviceContext* pContext;
    
    // USB 设备
    WDFUSBDEVICE UsbDevice;
    WDFUSBINTERFACE UsbInterface;
    WDFUSBPIPE BulkReadPipe;
    ULONG max_in_pkg_size;
    WDFUSBPIPE BulkWritePipe;
    ULONG max_out_pkg_size;
    ULONG UsbDeviceTraits;
    
    PSLIST_HEADER purb_list;
    
    // 配置
    config_cstr_t udisp_registry_dev_info;
    config_cstr_t udisp_dev_info;
    TCHAR tchar_udisp_devinfo[UDISP_CONFIG_STR_LEN];
    display_config_t display_config;
    
    // 状态
    usb_connection_state_t usb_state;
    perf_stats_t perf_stats;
    
    void Cleanup();
};
```

**显示配置** (display_config_t)：
| 字段 | 类型 | 说明 |
|------|------|------|
| `w` | `int` | 显示宽度 |
| `h` | `int` | 显示高度 |
| `enc` | `int` | 编码类型（0=RGB565, 1=RGB888, 3=JPEG） |
| `quality` | `int` | JPEG 质量（0-100） |
| `fps` | `int` | 目标帧率 |
| `blimit` | `int` | 缓冲区限制 |

---

### 3.3 USB 驱动模块 (usb_driver.cpp/h)

#### 3.3.1 URB 队列管理

**URB 结构** (urb_item_t)：
```cpp
typedef struct _urb_item {
    SLIST_ENTRY node;              // 单向链表节点
    WDFUSBPIPE pipe;               // USB 管道
    int id;                        // URB ID
    uint8_t urb_msg[1920 * 1080 * 4];  // 数据缓冲区
    PSLIST_HEADER urb_list;        // 所属队列头
    WDFREQUEST Request;            // WDF 请求对象
    WDFMEMORY wdfMemory;           // WDF 内存对象
} urb_item_t, *purb_item_t;
```

**初始化**：
```cpp
int usb_transf_init(SLIST_HEADER* urb_list)
```
- 初始化单向链表头
- 创建 USB 状态锁
- 分配 `MAX_URB_SIZE`（3）个 URB
- 为每个 URB 创建 WDF 请求对象
- 将所有 URB 推入空闲队列

**清理**：
```cpp
int usb_transf_exit(SLIST_HEADER* urb_list)
```
- 从队列弹出所有 URB
- 释放 WDF 请求和内存对象
- 释放 URB 内存

#### 3.3.2 异步数据发送

```cpp
NTSTATUS usb_send_msg_async(urb_item_t* urb, 
                            WDFUSBPIPE pipe, 
                            WDFREQUEST Request, 
                            PUCHAR msg, 
                            int tsize)
```

**功能**：
1. 检查 USB 连接状态
2. 创建 WDF 内存对象
3. 复制数据到 WDF 内存
4. 格式化 USB 写请求
5. 设置完成回调 `EvtRequestWriteCompletionRoutine`
6. 异步发送请求

**完成回调**：
```cpp
VOID EvtRequestWriteCompletionRoutine(
    WDFREQUEST Request,
    WDFIOTARGET Target,
    PWDF_REQUEST_COMPLETION_PARAMS CompletionParams,
    WDFCONTEXT Context)
```

**错误处理**：
- 失败时增加全局错误计数器
- 错误计数达到 `USB_ERROR_RESET_THRESHOLD`（5）时设置 USB 状态为 `USB_STATE_ERROR`
- 成功时重置错误计数器

#### 3.3.3 USB 接口选择

```cpp
NTSTATUS SelectInterfaces(WDFDEVICE Device)
```

**功能**：
1. 配置单个 USB 接口
2. 枚举所有管道
3. 识别 Bulk IN 和 Bulk OUT 管道
4. 设置 `max_in_pkg_size` 和 `max_out_pkg_size`

**管道识别**：
- Bulk IN：`WdfUsbPipeTypeBulk && WdfUsbTargetPipeIsInEndpoint()`
- Bulk OUT：`WdfUsbPipeTypeBulk && WdfUsbTargetPipeIsOutEndpoint()`

#### 3.3.4 USB 设备信息获取

```cpp
NTSTATUS get_usb_dev_string_info(WDFDEVICE Device, TCHAR* stringBuf)
```

**功能**：
1. 获取 USB 设备描述符（VID:PID）
2. 查询产品字符串（描述符索引 `iProduct`）
3. 返回设备配置字符串

**配置字符串格式**：
```
w=1920,h=1080,enc=1,quality=5,fps=60,blimit=8294400
```

#### 3.3.5 USB 连接管理

| 函数 | 功能 |
|------|------|
| `usb_device_connect()` | 设置 USB 状态为 `CONNECTED`，重置错误计数 |
| `usb_device_disconnect()` | 设置 USB 状态为 `DISCONNECTED` |
| `usb_device_reset()` | 重置 USB 管道，恢复连接 |

**重置流程**：
1. 设置状态为 `USB_STATE_RECOVERING`
2. 终止 Bulk OUT 管道
3. 重置 Bulk OUT 管道
4. 终止 Bulk IN 管道
5. 重置 Bulk IN 管道
6. 重置错误计数器
7. 重新选择接口
8. 根据结果设置状态为 `CONNECTED` 或 `ERROR`

#### 3.3.6 USB 错误恢复

```cpp
NTSTATUS usb_error_recovery(WDFDEVICE Device, NTSTATUS error_code)
```

**恢复策略**：

| 错误计数 | 策略 | 操作 |
|----------|------|------|
| < MAX_RETRY_COUNT (3) | RETRY | 不采取任何操作 |
| < USB_ERROR_RESET_THRESHOLD (5) | RESET | 调用 `usb_device_reset()` |
| >= USB_ERROR_RESET_THRESHOLD (5) | REINIT | 调用 `usb_device_reset()`，可能需要手动干预 |

---

### 3.4 图像编码模块 (image_encoder.c/h)

#### 3.4.1 编码器接口

```cpp
typedef struct _image_encoder {
    int type;                    // 编码类型
    int quality;                  // JPEG 质量
    
    int (*encode)(image_encoder_t* encoder,
                 uint8_t* output,
                 const uint8_t* input,
                 int x, int y, int right, int bottom,
                 int line_width, int limit);
    
    int (*encode_header)(image_encoder_t* encoder,
                         uint8_t* output,
                         int x, int y, int right, int bottom,
                         int total_bytes);
    
    void (*destroy)(image_encoder_t* encoder);
    
    void* jpeg_private;          // JPEG 专用数据
} image_encoder_t;
```

#### 3.4.2 编码类型

| 类型 | 常量 | 说明 |
|------|------|------|
| RGB565 | `IMAGE_TYPE_RGB565` | 16位 RGB，2字节/像素 |
| RGB888 | `IMAGE_TYPE_RGB888` | 24位 RGB，3字节/像素 |
| JPEG | `IMAGE_TYPE_JPG` | JPEG 压缩 |

#### 3.4.3 RGB565 编码

```cpp
image_encoder_t* image_encoder_create_rgb565(void)
```

**编码流程**：
1. 遍历每个像素（从 input 的 RGBA 格式）
2. 提取 R(5位)、G(6位)、B(5位)
3. 组合成 16 位值
4. 按小端序写入输出缓冲区

**位布局**：
```
[15:11] R4:R0 (5 bits)
[10:5]  G5:G0 (6 bits)
[4:0]   B4:B0 (5 bits)
```

#### 3.4.4 RGB888 编码

```cpp
image_encoder_t* image_encoder_create_rgb888(void)
```

**编码流程**：
1. 遍历每个像素（从 input 的 RGBA 格式）
2. 提取 R(8位)、G(8位)、B(8位)
3. 按顺序写入输出缓冲区（RGBRGB...）

#### 3.4.5 JPEG 编码

```cpp
image_encoder_t* image_encoder_create_jpeg(int quality)
```

**JPEG 初始化**：
1. 分配 `jpeg_compress_struct`
2. 分配 JPEG 错误处理器
3. 初始化压缩对象
4. 设置图像参数（宽度、高度、输入格式 JCS_RGB）
5. 设置质量参数（0-100）
6. 分配 `row_buffer`（行缓冲区）
7. 开始压缩

**JPEG 编码**：
```cpp
static int encode_jpeg_func(image_encoder_t* encoder,
                            uint8_t* output,
                            const uint8_t* input,
                            int x, int y, int right, int bottom,
                            int line_width, int limit)
```

**编码流程**：
1. 计算 ROI（感兴趣区域）
2. 重用 JPEG 压缩对象（`jpeg_abort_compress()`）
3. 设置输出缓冲区（`jpeg_mem_dest()`）
4. 启动压缩（`jpeg_start_compress()`）
5. 逐行压缩（`jpeg_write_scanlines()`）
6. 完成压缩（`jpeg_finish_compress()`）
7. 返回压缩后数据长度

**优化**：
- 重用 JPEG 压缩对象，避免重复初始化开销
- 动态调整 `row_buffer` 大小（仅在需要更大时重新分配）

**JPEG 销毁**：
```cpp
static void encode_jpeg_destroy(image_encoder_t* encoder)
```
1. 销毁 JPEG 压缩对象
2. 释放错误处理器
3. 释放行缓冲区
4. 释放 `jpeg_private` 结构

#### 3.4.6 帧头结构

```cpp
typedef struct _image_frame_header_t {
    _u32 magic_id;   // 0x55AA55AA
    _u32 img_type;   // 图像类型 (0=RGB565, 1=RGB888, 3=JPEG)
    _u32 img_len;    // 图像数据长度
    _u32 img_cnt;    // 帧计数
} image_frame_header_t;
```

**帧头设置**：
```cpp
int image_setup_frame_header(uint8_t* msg, 
                             uint32_t img_type, 
                             uint32_t img_len, 
                             uint32_t img_cnt)
```

---

### 3.5 工具模块 (tools.c/h)

#### 3.5.1 日志系统

**日志级别**：
```cpp
enum LogLevel {
    LOG_LEVEL_ERROR = 0,
    LOG_LEVEL_WARN = 1,
    LOG_LEVEL_INFO = 2,
    LOG_LEVEL_DEBUG = 3,
    LOG_LEVEL_TRACE = 4
};
```

**日志宏**：
| 宏 | 功能 |
|----|------|
| `LOGE(fmt, ...)` | ERROR 级别日志 |
| `LOGW(fmt, ...)` | WARN 级别日志 |
| `LOGI(fmt, ...)` | INFO 级别日志 |
| `LOGD(fmt, ...)` | DEBUG 级别日志 |
| `LOGM(fmt, ...)` | MSG 级别日志 |

**日志函数**：
```cpp
void tools_log(const char* fmt, ...)
```

#### 3.5.2 时间函数

```cpp
int64_t tools_get_time_us(void)
```

返回当前时间（微秒），用于性能测量。

#### 3.5.3 帧率控制

```cpp
void tools_sample_tick(int fps)
```

控制帧率，确保不超过目标 FPS。

**实现**：
- 计算帧间隔（1/fps 秒）
- 如果当前帧处理时间小于间隔，则睡眠剩余时间

#### 3.5.4 性能统计

```cpp
typedef struct _perf_stats {
    uint64_t total_frames;       // 总帧数
    uint64_t dropped_frames;     // 丢弃帧数
    uint64_t error_frames;       // 错误帧数
    uint64_t total_bytes;        // 总字节数
    uint64_t urbs_sent;          // 发送的 URB 数
    uint64_t urbs_failed;        // 失败的 URB 数
    int64_t avg_grab_time_us;    // 平均抓取时间
    int64_t avg_encode_time_us;  // 平均编码时间
    int64_t avg_send_time_us;    // 平均发送时间
    int64_t avg_total_time_us;   // 平均总时间
} perf_stats_t;
```

**初始化**：
```cpp
void tools_perf_stats_init(perf_stats_t* stats)
```

**更新**：
```cpp
void tools_perf_stats_update(perf_stats_t* stats,
                             int frame_size,
                             int64_t grab_time,
                             int64_t encode_time,
                             int64_t send_time,
                             int success)
```

**打印**：
```cpp
void tools_perf_stats_print(perf_stats_t* stats)
```

打印间隔：`STATS_PRINT_INTERVAL`（100帧）

#### 3.5.5 USB 配置解析

**配置字符串格式**：
```
w=1920,h=1080,enc=1,quality=5,fps=60,blimit=8294400
```

**解析函数**：
```cpp
int tools_split_config_str(char* str, usb_info_item_t* cfg, int max)
void tools_parse_usb_dev_info(char* str, usb_dev_config_t* config)
```

---

## 数据流程

### 4.1 初始化流程

```
DriverEntry
    ↓
registry_config_base()         [加载注册表配置]
    ↓
IddSampleDeviceAdd              [创建设备]
    ↓
注册 PnP/Power 回调
注册 IDDCX 回调
创建 WDF 设备对象
创建 IndirectDeviceContext
    ↓
IddSampleDeviceD0Entry          [设备启动]
    ↓
InitAdapter()                   [创建 IDDCX 适配器]
    ↓
IddSampleDevicePrepareHardware  [USB 设备准备]
    ↓
WdfUsbTargetDeviceCreate()      [创建 USB 设备]
SelectInterfaces()              [选择接口和管道]
get_usb_dev_string_info()       [获取设备配置]
tools_parse_usb_dev_info()      [解析配置]
usb_device_connect()            [标记已连接]
    ↓
FinishInit()
    ↓
CreateMonitor()                 [创建监视器]
    ↓
IddCxMonitorCreate()
IddCxMonitorArrival()
    ↓
IddSampleMonitorAssignSwapChain [分配 SwapChain]
    ↓
AssignSwapChain()
创建 SwapChainProcessor
decision_runtime_encoder()      [选择编码器]
usb_transf_init()               [初始化 URB 队列]
启动处理线程 RunThread()
    ↓
[主处理循环开始]
```

### 4.2 帧处理流程

```
[主循环]
    ↓
WaitForSingleObject(m_hAvailableBufferEvent)  [等待新帧]
    ↓
IddCxSwapChainReleaseAndAcquireBuffer()       [获取帧]
    ↓
检查 USB 连接状态
    ├─ 未连接 → 丢弃帧
    └─ 已连接 ↓
InterlockedPopEntrySList(urb_list)            [获取空闲 URB]
    ├─ 无 URB → 丢弃帧
    └─ 有 URB ↓
enc_grab_surface()                            [复制帧数据到 fb_buf]
    ↓
开始计时 (grab_time)
    ↓
encoder->encode()                              [编码]
    ├─ RGB565: 转换格式
    ├─ RGB888: 转换格式
    └─ JPEG: libjpeg-turbo 压缩
    ↓
结束计时 (encode_time)
    ↓
encoder->encode_header()                       [添加帧头]
    ↓
usb_send_msg_async()                          [异步发送]
    ↓
WdfMemoryCreate()
WdfMemoryCopyFromBuffer()
WdfUsbTargetPipeFormatRequestForWrite()
WdfRequestSetCompletionRoutine()
WdfRequestSend()
    ↓
等待完成回调 EvtRequestWriteCompletionRoutine
    ├─ 成功 → 重置错误计数，回收 URB
    └─ 失败 → 增加错误计数
        ├─ 达到阈值 → usb_error_recovery()
        └─ 未达阈值 → 继续发送
    ↓
结束计时 (send_time)
    ↓
tools_perf_stats_update()                     [更新统计]
    ↓
tools_sample_tick(fps)                         [帧率控制]
    ↓
IddCxSwapChainFinishedProcessingFrame()        [完成帧处理]
    ↓
[回到循环开始]
```

### 4.3 数据转换流程

```
[Windows Desktop]
    ↓ DXGI Surface
[DXGI SwapChain]
    ↓ AcquiredBuffer
[IDDCX Framework]
    ↓ IDXGIResource
[Direct3DDevice]
    ↓ CreateTexture2D
    ↓ CopySubresourceRegion
    ↓ Map
[fb_buf] (CPU, RGBA, 1920x1080x4)
    ↓ encoder->encode()
[Image Encoder]
    ├─ RGB565 → [fb_buf] (RGB565, 1920x1080x2)
    ├─ RGB888 → [fb_buf] (RGB888, 1920x1080x3)
    └─ JPEG   → [fb_buf] (JPEG compressed)
    ↓ encoder->encode_header()
[image_frame_header_t + payload]
    ↓ usb_send_msg_async()
[URB Queue] → WDF Memory Object
    ↓ USB Bulk Write Pipe
[USB Device]
```

---

## 接口设计

### 5.1 IDDCX 回调接口

#### 5.1.1 适配器回调

**IddSampleAdapterInitFinished**
```cpp
EVT_IDD_CX_ADAPTER_INIT_FINISHED IddSampleAdapterInitFinished;
```
适配器初始化完成回调。

**IddSampleAdapterCommitModes**
```cpp
EVT_IDD_CX_ADAPTER_COMMIT_MODES IddSampleAdapterCommitModes;
```
提交显示模式变更。

#### 5.1.2 监视器回调

**IddSampleParseMonitorDescription**
```cpp
EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION IddSampleParseMonitorDescription;
```
解析监视器 EDID 描述。

**IddSampleMonitorGetDefaultModes**
```cpp
EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES IddSampleMonitorGetDefaultModes;
```
获取默认显示模式列表。

**IddSampleMonitorQueryModes**
```cpp
EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES IddSampleMonitorQueryModes;
```
查询监视器支持的模式。

#### 5.1.3 SwapChain 回调

**IddSampleMonitorAssignSwapChain**
```cpp
EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN IddSampleMonitorAssignSwapChain;
```
分配 SwapChain 给监视器。

**IddSampleMonitorUnassignSwapChain**
```cpp
EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN IddSampleMonitorUnassignSwapChain;
```
释放监视器的 SwapChain。

### 5.2 WDF 回调接口

#### 5.2.1 PnP/Power 回调

**IddSampleDeviceD0Entry**
```cpp
EVT_WDF_DEVICE_D0_ENTRY IddSampleDeviceD0Entry;
```
设备进入 D0（工作）状态。

**IddSampleDevicePrepareHardware**
```cpp
EVT_WDF_DEVICE_PREPARE_HARDWARE IddSampleDevicePrepareHardware;
```
准备硬件资源（USB 设备初始化）。

**IddSampleDeviceReleaseHardware**
```cpp
EVT_WDF_DEVICE_RELEASE_HARDWARE IddSampleDeviceReleaseHardware;
```
释放硬件资源（USB 设备清理）。

**IddSampleDeviceSurpriseRemoval**
```cpp
EVT_WDF_DEVICE_SURPRISE_REMOVAL IddSampleDeviceSurpriseRemoval;
```
处理设备意外拔出。

### 5.3 内部函数接口

#### 5.3.1 表面抓取

```cpp
int enc_grab_surface(std::shared_ptr<Direct3DDevice> m_Device,
                     ComPtr<IDXGIResource> AcquiredBuffer,
                     uint8_t *fb_buf,
                     D3D11_TEXTURE2D_DESC *pDesc)
```

**功能**：从 DXGI 资源抓取表面数据到 CPU 缓冲区。

**参数**：
- `m_Device`：Direct3D 设备
- `AcquiredBuffer`：DXGI 资源（帧数据）
- `fb_buf`：输出缓冲区
- `pDesc`：纹理描述符

**流程**：
1. 获取纹理接口
2. 创建 Staging Texture（支持 CPU 访问）
3. 复制纹理到 Staging Texture
4. 映射 Staging Texture
5. 复制数据到输出缓冲区
6. 取消映射

---

## 配置管理

### 6.1 注册表配置

**路径**：
```
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IddSampleDriver\Parameters
```

**配置项**：

| 名称 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `debug_level` | REG_DWORD | 2 | 日志级别（0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=TRACE） |

### 6.2 USB 设备配置

**配置字符串格式**：
```
w=1920,h=1080,enc=1,quality=5,fps=60,blimit=8294400
```

**参数说明**：

| 参数 | 类型 | 默认值 | 范围 | 说明 |
|------|------|--------|------|------|
| `w` | int | 1920 | 1-1920 | 显示宽度 |
| `h` | int | 1080 | 1-1080 | 显示高度 |
| `enc` | int | 1 | 0-3 | 编码类型（0=RGB565, 1=RGB888, 3=JPEG） |
| `quality` | int | 5 | 0-100 | JPEG 质量 |
| `fps` | int | 60 | 1-120 | 目标帧率 |
| `blimit` | int | 8294400 | - | 缓冲区限制（字节） |

**配置来源**：
1. USB 设备描述字符串（`iProduct` 字段）
2. 如果设备描述无效，使用默认值

### 6.3 编译时配置

**常量定义** (basetype.h)：

```cpp
#define DEFAULT_WIDTH         1920
#define DEFAULT_HEIGHT        1080
#define DEFAULT_FPS           60
#define DEFAULT_JPEG_QUALITY  5
#define DEFAULT_BUFFER_LIMIT  (DEFAULT_WIDTH * DEFAULT_HEIGHT * 4)
#define DISP_MAX_WIDTH        1920
#define DISP_MAX_HEIGHT       1080
#define MAX_URB_SIZE          3
#define MAX_RETRY_COUNT       3
#define USB_ERROR_RESET_THRESHOLD 5
```

---

## 错误处理

### 7.1 USB 连接状态

```cpp
typedef enum _usb_connection_state {
    USB_STATE_DISCONNECTED = 0,
    USB_STATE_CONNECTED = 1,
    USB_STATE_ERROR = 2,
    USB_STATE_RECOVERING = 3
} usb_connection_state_t;
```

**状态转换图**：
```
DISCONNECTED
    ↓ [usb_device_connect()]
CONNECTED
    ↓ [USB error < USB_ERROR_RESET_THRESHOLD]
    ↓ [重试]
CONNECTED
    ↓ [USB error >= USB_ERROR_RESET_THRESHOLD]
    ↓ [usb_device_reset()]
RECOVERING
    ↓ [重置成功]
CONNECTED
    ↓ [重置失败]
ERROR
    ↓ [usb_device_disconnect()]
DISCONNECTED
```

### 7.2 错误恢复策略

| 错误场景 | 检测方式 | 恢复策略 |
|----------|----------|----------|
| USB 发送失败 | `!NT_SUCCESS(status)` | 重试 → 重置 → 人工干预 |
| USB 管道挂起 | 发送超时 | `usb_device_reset()` |
| 设备意外拔出 | SurpriseRemoval 回调 | `usb_device_disconnect()` |
| URB 队列耗尽 | `InterlockedPopEntrySList()` 返回 NULL | 丢弃帧，等待 URB 回收 |
| USB 未连接 | `usb_state != USB_STATE_CONNECTED` | 丢弃帧，等待重连 |

### 7.3 错误计数机制

**全局错误计数器**：
```cpp
static LONG g_usb_error_count = 0;
```

**计数器更新**：
- 发送失败：`InterlockedIncrement(&g_usb_error_count)`
- 发送成功：`InterlockedExchange(&g_usb_error_count, 0)`

**阈值**：
- `MAX_RETRY_COUNT` (3)：重试阈值
- `USB_ERROR_RESET_THRESHOLD` (5)：重置阈值

### 7.4 日志记录

**日志级别**：
```cpp
enum LogLevel {
    LOG_LEVEL_ERROR = 0,   // 错误
    LOG_LEVEL_WARN = 1,    // 警告
    LOG_LEVEL_INFO = 2,    // 信息
    LOG_LEVEL_DEBUG = 3,   // 调试
    LOG_LEVEL_TRACE = 4    // 跟踪
};
```

**典型错误日志**：
```
[ERROR] Write failed: request Status 0xC0000001 UsbdStatus 0xC0000001
[ERROR] USB error threshold reached, state set to ERROR
[WARN] Failed to abort write pipe: 0xC0000001
[INFO] USB device reset successful
[INFO] USB device connected successfully
```

---

## 性能优化

### 8.1 URB 池化

**优化目标**：减少内存分配开销

**实现**：
- 初始化时分配 `MAX_URB_SIZE`（3）个 URB
- 使用单向链表 (`SLIST_HEADER`) 管理空闲 URB
- 发送后 URB 被回收，重复使用

**优势**：
- 避免频繁的内存分配/释放
- 无锁操作（`InterlockedPushEntrySList`/`InterlockedPopEntrySList`）

### 8.2 JPEG 编码优化

**重用压缩对象**：
```cpp
// 不创建新的压缩对象，而是重用
jpeg_abort_compress(&cinfo);
```

**动态行缓冲区**：
- 仅在需要更大行缓冲区时重新分配
- 避免不必要的内存复制

### 8.3 异步传输

**异步发送**：
```cpp
usb_send_msg_async() → 不阻塞，立即返回
完成回调 → EvtRequestWriteCompletionRoutine
```

**优势**：
- 处理线程不被阻塞
- 允许并发的帧处理和 USB 传输

### 8.4 帧率控制

**实现**：
```cpp
void tools_sample_tick(int fps)
{
    // 计算帧间隔
    // 如果处理时间小于间隔，则睡眠
}
```

**效果**：
- 避免不必要的 CPU 占用
- 平滑的帧输出

### 8.5 性能统计

**监控指标**：
| 指标 | 说明 |
|------|------|
| `grab_time` | GPU → CPU 拷贝时间 |
| `encode_time` | 图像编码时间 |
| `send_time` | USB 发送时间 |
| `total_frames` | 总帧数 |
| `dropped_frames` | 丢弃帧数 |
| `urbs_sent` | 发送的 URB 数 |
| `urbs_failed` | 失败的 URB 数 |

---

## 编译与部署

### 9.1 编译环境

| 组件 | 版本 |
|------|------|
| Visual Studio | 2022 |
| Windows SDK | 10.0.26100.0 |
| WDK | Windows Driver Kit |
| 驱动模型 | UMDF 2.0 |

### 9.2 编译配置

**平台**：x64

**配置**：
- Debug：调试符号，无优化
- Release：优化，代码签名

**关键设置**：
- 链接器 → 输入 → 附加依赖项：`OneCoreUAP.lib;avrt.lib;jpeg-static.lib`
- 链接器 → 常规 → 附加库目录：`$(ProjectDir)lib`
- C/C++ → 常规 → 附加包含目录：`$(ProjectDir)include`
- DriverSign → FileDigestAlgorithm：`SHA256`

### 9.3 依赖库

**JPEG 库**：
- 位置：`lib/jpeg-static.lib`
- 来源：libjpeg-turbo
- 头文件：`include/`

### 9.4 安装步骤

1. **签名驱动**：
   ```cmd
   certmgr /add certificate.cer /s /r localMachine root
   ```

2. **安装驱动**：
   - 方法 1：设备管理器 → 添加旧式硬件
   - 方法 2：`pnputil /add-driver IddSampleDriver.inf /install`

3. **配置注册表**（可选）：
   ```
   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IddSampleDriver\Parameters
   debug_level = 3 (DEBUG)
   ```
4. **设备描述配置**
```
    U0_R800x480x30_E3x10_D4x5
    U0          ->0 注册ID号为0
    R800x480x30 ->800:480:30 分辨率为800x480，帧率为30fps
    E3x10       ->3:10 JPEG编码，质量为10 (0:RGB565 1:RGB888 2:YUV420 3:JPEG) 
    D4x5        ->4:5 TRACE, 每个周期休眠5S (0:ERROR 1:WARN 2:INFO 3:DEBUG 4:TRACE)  
```


### 9.5 调试

**日志查看**：
- 使用 DebugView (DebugView++) 查看 WPP 追踪日志
- 设置日志级别：修改注册表 `debug_level`

**常见问题**：
| 问题 | 原因 | 解决方法 |
|------|------|----------|
| 驱动无法加载 | 未签名 | 安装测试证书 |
| 无输出图像 | USB 未连接 | 检查 USB 设备 |
| 闪烁/丢帧 | URB 耗尽 | 增加 `MAX_URB_SIZE` |
| 编码失败 | JPEG 质量 | 调整 `quality` 参数 |

---

## 附录

### A. 文件清单

| 文件 | 类型 | 说明 |
|------|------|------|
| `Driver.cpp` | C++ | 驱动主逻辑 |
| `Driver.h` | C++ | 驱动头文件 |
| `usb_driver.cpp` | C++ | USB 驱动实现 |
| `usb_driver.h` | C++ | USB 驱动接口 |
| `image_encoder.c` | C | 图像编码器 |
| `image_encoder.h` | C | 编码器接口 |
| `tools.c` | C | 工具函数 |
| `tools.h` | C | 工具函数接口 |
| `basetype.h` | C | 基础类型定义 |
| `Trace.h` | C | WPP 追踪定义 |
| `IddSampleDriver.inf` | INF | 驱动安装文件 |
| `IddSampleDriver.vcxproj` | XML | VS 项目文件 |

### B. 常量定义

**显示相关**：
```cpp
#define DISP_MAX_WIDTH  1920
#define DISP_MAX_HEIGHT 1080
```

**USB 相关**：
```cpp
#define MAX_URB_SIZE 3
#define MAX_RETRY_COUNT 3
#define USB_ERROR_RESET_THRESHOLD 5
```

**时间相关**：
```cpp
#define WAIT_TIMEOUT_MS 16
#define STATS_PRINT_INTERVAL 100
```

**图像类型**：
```cpp
#define IMAGE_TYPE_RGB565  0
#define IMAGE_TYPE_RGB888  1
#define IMAGE_TYPE_YUV420  2
#define IMAGE_TYPE_JPG     3
```

### C. 参考资料

1. [Microsoft Indirect Display Driver Documentation](https://docs.microsoft.com/en-us/windows-hardware/drivers/display/indirect-display)
2. [WDF USB Device Driver Reference](https://docs.microsoft.com/en-us/windows-hardware/drivers/wdf/)
3. [libjpeg-turbo Documentation](https://libjpeg-turbo.org/Documentation.html)
4. [DXGI Documentation](https://docs.microsoft.com/en-us/windows/win32/direct3ddxgi/dx-graphics-dxgi)

---

## 版本历史

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|----------|
| v1.0 | 2025-01-27 | Modified | 初始版本，添加 USB 传输和 JPEG 编码支持 |

---

**文档结束**
